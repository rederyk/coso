# Fix: TTS Audio Playback for 32-bit Float WAV Files

## Problem

The device was unable to play audio generated by the local `tts-webui` server, which was configured to use the `hexgrad/Kokoro-82M` model. The device logs consistently showed the following error upon attempting playback:

```
[ERROR] WavDecoder: Only PCM format supported (got format 3)
```

This error indicated that the TTS service was generating a WAV file with `audio_format = 3`, which corresponds to 32-bit IEEE floating-point samples. The device's `WavDecoder` was only capable of handling `audio_format = 1` (16-bit integer PCM).

## Investigation

The investigation followed two main paths:

### 1. Modifying the Server Request

The initial approach was to instruct the server to send audio in a different, compatible format.
- **Requesting MP3:** An attempt was made to change the `response_format` in the TTS request from `"wav"` to `"mp3"`. This failed, as the user reported the server still sent WAV data, just with an `.mp3` extension.
- **Requesting Specific WAV Encoding:** Based on presets found in the `tts-webui`, a `dtype` parameter was discovered. An attempt was made to add `"params": {"dtype": "int16"}` to the request, explicitly asking for 16-bit PCM WAV data.

Both attempts were unsuccessful. The server appeared to ignore these parameters and consistently provided a 32-bit float WAV file. This suggested the issue could not be resolved by altering the client's request.

### 2. Modifying the Client-Side Decoder

With the server's output being unchangeable, the focus shifted to enhancing the client's decoding capabilities.
- The `WavDecoder` responsible for the error was located at `lib/openESPaudio/src/wav_decoder.cpp`.
- The plan was to modify this decoder to handle 32-bit float audio by converting it on-the-fly to the 16-bit PCM format expected by the rest of the audio pipeline.

## Solution

The `WavDecoder` within the `openESPaudio` library was successfully modified to support 32-bit IEEE float WAV files. The following changes were implemented in `lib/openESPaudio/src/wav_decoder.h` and `lib/openESPaudio/src/wav_decoder.cpp`:

1.  **Header Parsing:** The `parse_wav_header` function was updated to accept `audio_format = 3` as a valid format, in addition to the existing `audio_format = 1`.
2.  **Format Validation:** The `init` function was adjusted to validate the `bits_per_sample` correctly for each format (16 for PCM, 32 for float).
3.  **Float-to-PCM Conversion:** The core of the solution was implemented in the `read_frames` function. A new logic path was added:
    - If the audio format is `3` (float), the function reads the 32-bit float samples into a temporary buffer.
    - It then iterates through the buffer, converting each float sample (in the range `[-1.0, 1.0]`) to a 16-bit signed integer sample by multiplying it by `32767.0f`.
    - The resulting 16-bit PCM data is written to the destination buffer, which is then passed to the audio output pipeline.
4.  **Memory Safety:** A potential stack overflow bug in the initial modification was identified and fixed. The temporary buffer for float samples is now allocated on the heap using `new[]` and `delete[]` instead of using a variable-length array (VLA) on the stack.
5.  **Seeking:** The `seek_to_frame` function was also updated to use the correct sample size (`bits_per_sample`) when calculating byte offsets, ensuring seeking works for both PCM and float files.

This solution resolved the playback issue by making the device's decoder robust enough to handle the specific audio format provided by the local TTS server.